---
layout: post
title: '[운영체제 기초 다지기] Process (2)'
description: '스레드: 프로세스 하나에 CPU의 수행 단위만 여러 개 두는 것, 즉, 스레드 = CPU 실행 단위'
featured: false
author: admin
categories: [os]
tags: [운영체제 기초]
image: 'https://github.com/nvrtmd/nvrtmd/assets/67324487/47d35953-bdd3-474c-9720-b820b3adedc8'
# beforetoc: ""
toc: true
# rating: 3
hidden: false
---

# 스레드

## 스레드의 개념

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/2f874584-6dbc-4794-941d-8a973f3c1461)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/e6a246f7-a5d9-4b8a-9901-d806325cd37a)

- 스레드: 프로세스 하나에 CPU의 수행 단위만 여러 개 두는 것, 즉, 스레드 = CPU 실행 단위
  - 프로세스 하나만 Running하고, 현재 CPU가 해당 프로세스의 코드의 어느 부분을 실행하고 있는지에 대한 프로그램 카운터와 레지스터 내의 값에 대한 정보를 여러 개 두는 것
  - 각 스레드마다 주소 공간 내에서 스택, PCB 내에서 레지스터 셋, 프로그램 카운터를 별도로 갖고 있음
    - 프로세스의 instruction을 실행하려면 프로그램 카운터 있어야 함
    - CPU에서 instruction이 실행되면서 메모리 레지스터에 값들을 세팅함
    - 프로세스에서 함수를 호출하면 함수 호출 및 리턴 관련 정보를 주소공간 내 스택에 쌓음
    - 따라서 스레드끼리 공유할 수 있는 만큼 최대한 공유하되, CPU 수행과 관련된 것들만(PC, 레지스터 셋, 스택) 스레드마다 별로도 갖게 됨
- Lightweight process: 프로세스를 별도로 두는 것보다 프로세스 안에 스레드를 별도로 두는 게 낫기 때문에 Lightweight process라고 칭함
  - 동일한 작업을 수행하는 프로세스가 여러 개 있으면 프로세스마다 독자적인 주소 공간이 만들어지기 때문에 공간이 낭비됨

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/e0c36381-37ec-48cd-bddf-597378e13f1a)

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/ab3a302e-2853-464f-909c-b5e9226a3ed4)

- 하나의 프로세스에 대해 한 개의 PCB가 생성되며, 프로세스 내 스레드가 여러 개면 코드, 데이터와 같은 여러 자원들은 스레드들끼리 공유하되 CPU 수행과 관련된 정보만(PC, 레지스터 셋) 스레드 별로 카피해서 갖게 됨

## 스레드의 장점

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/c1427a70-7f87-4d30-8c84-16722aca0865)

- 스레드 하나가 Blocked(waiting) 상태일 때 동일한 태스크 내의 다른 스레드가 Running되어 응답 시간이 빨라짐
  - 예를 들어, 네이버에 접속했을 때 네트워크를 통해 인터넷 페이지를 읽어오는(IO) 시간이 오래 걸리므로 웹 브라우저가 Blocked됨 → 해당 프로세스를 Blocked 시기는 게 아니라 하나의 스레드가 웹 페이지 내의 이미지를 불러오는 동안, 또 다른 스레드가 이미 읽어온 텍스트를 화면에 띄워주는 식으로 작업하면 사용자의 답답함이 덜함
  - 하나의 스레드가 A 작업을 하는 동안 다른 스레드들이 B, C…작업을 할 수 있어서 응답 시간 짧아질 수 있음
- 같은 일(ex. 인터넷 페이지 읽어오기)을 할 때 세부 작업(페이지 내 이미지 읽어오기, 텍스트 읽어오기 등)에 대한 프로세스를 따로따로 만들면 메모리를 많이 차지하게 됨 → 주소 공간(프로세스)를 하나만 띄워 놓고 스레드를 여러 개 둠 → 성능 향상

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/26343643-c87a-46a0-80c3-9c37dfa80ad3)

- 스레드 사용 시 장점 4가지
  - Responsiveness 응답성
    - 웹 브라우저로 네이버에 접속했을 경우
      - HTML 문서 수신 → 문서에 임베드된 이미지들을 웹 서버에 요청 → 이미지를 수신하면 화면에 텍스트와 이미지를 표시하게 되는데, 그 과정에서 시간이 소요되어 프로세스를 Blocked 시킴 → 사용자 입장에서는 지연으로 인해 불편함
    - 여러 개의 스레드를 갖고 있는 웹 브라우저로 접속했을 경우
      - HTML 문서 수신한 뒤 임베드된 이미지 파일들을 웹 서버에 요청 → 프로세스를 Blocked 시키지 않고, 웹 서버에 요청한 그 스레드만 Blocked 되고 다른 스레드가 수신된 문서라도 화면에 표시주면 사용자 입장에서 덜 불편함
      - 이미지를 수신하는 동안, 즉, IO 실행하는 동안 이 프로세스 자체를 Blocked 시키는 것이 아니라 이미지를 수신하는 결과와 무관하게화면에 HTML 문서를 먼저 표시해주는 것 (일종의 비동기식)
  - Resource Sharing 자원의 공유
    - 똑같은 작업을 하는 프로세스를 여러 개 두지 않고, 하나의 프로세스를 두고 그 안에 CPU 수행 단위(스레드)만 여러 개 둘 경우 코드, 데이터, 각종 자원을 스레드들 간에 공유하게 됨 → 자원을 효율적으로 사용하는 효과
  - Economy 경제성
    - 프로세스를 하나 만드는 것은 상당한 오버헤드 발생함 / 그러나 프로세스 내부에 스레드를 하나 추가하는 것은 오버헤드 크지 않음
    - Context Switching이 발생할 때 오버헤드 큼 / 프로세스 내부에서 스레드 간 switching 일어나는 것은 동일한 주소 공간을 사용하고 있으므로 대부분의 문맥을 그대로 사용할 수 있어서 오버헤드 작음
  - Utilization of MP Architectures
    - CPU가 여러 개일 경우 각각의 스레드가 서로 다른 CPU에서 병렬적으로 일하므로 더 효율적임

## 구현 방식에 의한 분류

![Untitled](https://github.com/nvrtmd/nvrtmd/assets/67324487/680288b5-9f9e-4c81-8596-0d960739abdb)

- 스레드 구현 방식
  - 커널 스레드: 스레드가 여러 개 있다는 사실을 운영체제 커널이 인지하고 있음 → 하나의 스레드에서 다른 스레드로 CPU 제어권을 넘겨주는 역할을 커널이 담당함
  - 유저 스레드: 라이브러리를 통해 지원됨 → 프로세스 안에 스레드가 여러 개 있다는 사실을 운영체제는 인지하지 못하고 유저 프로그램이 스스로 라이브러리 지원을 받아서 여러 개의 스레드를 관리함 → 그러므로 유저 스레드는 커널이 모르고 있고, 커널이 볼 때는 일반적인 프로세스로 보이는데, 프로세스 본인 내부에서 CPU 수행 단위를 여러 개 두는 것이므로 구현 상에 제약이 있을 수 있음
    - 사용자 수준에서 스레드를 구현한 것

[출처](http://www.kocw.net/home/search/kemView.do?kemId=1046323&ar=pop)
