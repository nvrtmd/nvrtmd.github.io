---
layout: post
title: '[운영체제 기초 다지기] System Structure & Program Execution (2)'
description: '입출력의 실행: 동기/비동기식 입출력'
featured: false
author: admin
categories: [os]
tags: [운영체제 기초]
image: 'https://user-images.githubusercontent.com/67324487/235317328-02106f6c-2526-47c2-b162-e1f72b9053cd.png'
# beforetoc: ""
toc: true
# rating: 3
hidden: false
---

# 컴퓨터 시스템 구조

## 입출력의 실행

### 동기/비동기식 입출력

![Untitled](https://user-images.githubusercontent.com/67324487/235317366-03cf571c-8b42-4665-a7a6-206c28046d7c.png)

![Untitled](https://user-images.githubusercontent.com/67324487/235317381-cc3d1ebf-6a5b-49f2-9dd8-f1e52ad3d34b.png)

- 동기식 입출력
  - IO 작업 요청 → 작업 완료된 후에야 사용자 프로그램으로 CPU 제어권이 넘어가는 것
    - 즉, 완료된 작업물을 직접 확인한 뒤 읽어와서 중단했던 작업을 이어나가는 것
  - 구현 방법
    1. IO 작업이 완료될 때까지 대기하는 경우
       - CPU 뿐만 아니라 IO 장치 역시 한 가지 일만 하고 있으므로 낭비
    2. IO를 요청한 프로세스 말고 (IO 작업이 당장 필요하지 않은)다른 프로세스에게 CPU 제어권 양도
       - CPU와 IO장치 모두 낭비되지 않음
       - 단, IO 작업을 요청한 프로세스는 IO 작업이 완료될 때까지 다음 작업을 수행하지 못하고 기다려야 한다는 점은 여전함
- 비동기식 입출력
  - IO 작업 요청 → IO 작업이 진행되는 동안 무관한 다른 작업 실행하는 것
    - IO 작업의 결과를 확인하지 않아도 할 수 있는 작업을 실행하다가 IO 결과가 나오면 그와 연관된 작업을 이어나가는 것
- 동기/비동기식 입출력의 비교
  - 프로세스가 입출력을 요청하기 위해 인터럽트를 통해 CPU 제어권을 운영체제로 양도 → IO 작업은 시간이 많이 소요됨
    - 동기식: 프로세스가 IO 작업이 진행되는 동안 관계 없는 다른 명령어를 실행하지 않고 기다림
    - 비동기식: IO 작업 요청 후 기다림 없이 바로 다른 명령어 실행

### 서로 다른 입출력 명령어

![Untitled](https://user-images.githubusercontent.com/67324487/235317442-f0c88048-913e-41bc-99a3-dd21dd0d5569.png)

- IO를 수행하는 특별한 명령어에 의해 실행(좌측)
  - 일반적인 IO 작업
  - CPU가 실행하는 명령어는 메모리에 접근하는 경우와 IO 장치에 접근하는 경우로 나뉨
    - 즉, 메모리 접근 명령어 따로, IO 작업을 요청하는 명령어 따로 존재함
- Memory Mapped IO에 의해 실행(우측)
  - IO 장치들에 메모리 주소의 연장 주소를 부여한 뒤, 해당 주소로 메모리 접근 시 IO 작업을 수행하게 함
    - 즉, 만약 100번지에 대해 메모리 접근을 하면 일반적인 메모리 접근이고, 1000번지에 대해 접근하면 IO 작업을 수행함

### cf. 저장장치 계층 구조

![Untitled](https://user-images.githubusercontent.com/67324487/235317466-2c0babe9-c59d-45aa-937a-a191a250e86a.png)

![Untitled](https://user-images.githubusercontent.com/67324487/235317482-65cc2039-6d07-4633-b99f-96ca7ca8edae.png)

- 특징: 표의 상위에 위치할수록 속도가 빠르며, 단위 공간 당 가격이 비싸서 용량이 적음
  - Volatility: 휘발성의 유무 → 상위 세 개의 저장장치는 휘발성이며, 하위 세 개는 비휘발성
  - Primary/Secondary: CPU에서 직접 접근 가능한지 여부 → 바이트 단위로 접근이 가능하면 Primary, 그렇지 않으면 Secondary
- 캐싱: 메모리 간 속도 차이가 존재 → 속도 완충을 위해 캐시가 존재
  - 목적: 재사용
  - 이전에 요청했던 데이터와 같은 데이터를 요청하는 경우 메인 메모리까지 내려가지 않고 캐시에 저장된 데이터를 사용할 수 있음 → 속도 면에서 이점

## 프로그램의 실행

![Untitled](https://user-images.githubusercontent.com/67324487/235317496-ac528f5c-269f-48c6-8f39-7f368d16d946.png)

![Untitled](https://user-images.githubusercontent.com/67324487/235317508-a4a17ef3-0e4e-499f-86ef-68d9dc705446.png)

### Swap Area/Virtual Memory

- 프로그램
  - 실행 파일 형태로 하드 디스크에 저장되어 있음 → 메모리에 적재됨으로써 실행됨
- Swap Area과 Virtual Memory(가상 메모리)
  - 프로그램 실행 → 프로그램의 독자적인 주소 공간이 생성됨
    - 해당 주소 공간은 코드, 데이터, 스택 등으로 구성됨
  - 프로그램의 코드는 물리적인 메모리에 올라가야 실행이 되는데, 프로그램의 모든 코드를 통째로 올릴 시 메모리 낭비 문제 발생 → 당장 필요한 부분만 올려두고 그렇지 않은 부분은 디스크의 swap area라는 공간에 내려둠
    - Swap Area
      - 위 그림에 존재하는 두 개의 노란색 원통은 하드 디스크
        - 오른쪽: 파일 시스템 용도로 사용되며 컴퓨터의 전원이 꺼져도 파일의 내용을 유지함
        - 왼쪽(Swap Area): 메모리의 한계를 보완하기 위해 메모리 대용 공간으로 사용되며 전원이 꺼지면 필요 없어지는 정보들을 담음
  - 가상 메모리(Virtual Memory): 각 프로그램마다 독자적으로 가지는 메모리 주소 공간
    - 각 프로그램마다 주소 공간이 각각 존재하며, 물리적인 메모리에 올라갈 시 주소 변환 일어남(Address transition)

### 운영체제 커널의 주소 공간의 내용

![Untitled](https://user-images.githubusercontent.com/67324487/235317529-643f125c-6667-4b96-9934-74e8a2835591.png)

- 커널의 코드 영역
  - 시스템 콜 및 인터럽트를 처리하는 코드, 자원 관리를 위한 코드 등이 존재하는 영역
    - 운영체제는 인터럽트가 들어올 시 CPU 제어권을 획득할 수 있음 → 각 인터럽트 별로 어떤 작업을 처리해야 하는지 함수 형태로 구현되어 있음(=인터럽트 처리 코드)
- 커널의 데이터 영역
  - 운영체제가사용하는 여러 자료구조들이 정의되어 있는 영역
  - 하드웨어를 관리하기 위해 하드웨어 종류마다 자료 구조를 만들어서 관리
  - 프로세스들을 관리하므로 각 프로그램들을 관리하기 위한 자료 구조(PCB)가 존재하는 영역
- 커널의 스택 영역
  - 사용자 프로그램 별로 커널 스택을 따로 둠

### 사용자 프로그램이 사용하는 함수

![Untitled](https://user-images.githubusercontent.com/67324487/235317551-9c5518ea-ddc8-441d-91e2-8ab5622da271.png)

- 컴파일되어 실행 파일이 만들어지면 함수들은 사용자 정의 함수, 라이브러리 함수 등 종류와 관계 없이 다 해당 실행 파일 내에 포함됨
- 커널 함수
  - 운영체제 안에서 정의된 함수
  - 사용자 프로그램 내에 존재하는 것이 아닌, 커널 코드 내의 함수 → 해당 함수는 시스템 콜을 통해서만 호출 가능
    - 코드가 존재하는 영역 자체가 달라서 메모리 점프 불가능 → 시스템 콜을 통해 인터럽트 라인을 세팅하여 실행해야 함

### 프로그램 실행 과정

![Untitled](https://user-images.githubusercontent.com/67324487/235317566-dcf64984-c0f0-4bc0-a3d7-1e6f4c039548.png)

1. 사용자 프로그램 A 실행
2. A가 직접 CPU 제어권을 갖고 실행되는 유저 모드 내에서 실행됨 → 사용자 정의 함수 사용 가능
3. 커널 함수가 필요한 상황 발생 → 시스템 콜(인터럽트)
4. CPU 제어권이 운영체제로 양도되며 커널 모드로 전환 → 커널 모드에서 CPU가 동작하며 커널 주소 공간 내의 코드가 실행됨
5. 필요한 작업이 마무리되어 A에게 CPU 제어권이 넘어가고, A는 본인의 주소 공간 내의 코드를 실행
6. 프로그램 실행이 끝날 때까지 유저 모드 - 커널 모드를 반복

[출처](http://www.kocw.net/home/search/kemView.do?kemId=1046323&ar=pop)
