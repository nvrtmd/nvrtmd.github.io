---
layout: post
title: '[운영체제 기초 다지기] System Structure & Program Execution (1)'
description: 'CPU: 중앙 처리 장치, 프로그램의 연산을 실행하고 처리하는 핵심 제어 장치'
featured: false
author: admin
categories: [os]
tags: [운영체제 기초]
image: 'https://user-images.githubusercontent.com/67324487/230755940-a0eb8e60-e100-419a-b0f8-5aefe9ee1698.png'
# beforetoc: ""
toc: true
# rating: 3
hidden: false
---

# 컴퓨터 시스템 구조

## 컴퓨터 시스템 구조와 운영체제의 역할

![Untitled](https://user-images.githubusercontent.com/67324487/230755996-10f4d8f5-3e3a-4c57-b48c-ebf835cbb1fd.png)

![Untitled](https://user-images.githubusercontent.com/67324487/230756004-c16dd3b8-79ee-4ebd-a84b-baa08cb8e00d.png)

### 시스템 구성요소

- CPU: 중앙 처리 장치
  - 프로그램의 연산을 실행하고 처리하는 핵심 제어 장치
  - 프로그램 카운터라는 레지스터에서 메모리 주소를 읽어온 뒤, 그 메모리에 저장된 명령어(instruction)를 실행함
- 인터럽트 라인: 시스템에서 인터럽트를 처리하기 위한 하드웨어 라인
  - 컨트롤러가 인터럽트를 요청할 때 신호를 보내는 하드웨어 라인
    - CPU가 하나의 명령어를 실행 완료할 때마다 감지

![Untitled](https://user-images.githubusercontent.com/67324487/230756003-b50213e9-83b5-48c5-aa5b-44a0f3a3a0d0.png)

- 모드비트: CPU에서 실행되고 있는 것이 운영체제인지 사용자 프로그램인지 구분하는 역할 수행
  - 사용자 모드(1): 사용자 프로그램을 수행
    - CPU가 사용자 프로그램을 실행 중일 때
    - 제한된 instruction만 실행 가능하며 IO 장치 접근 불가
    - 운영체제가 CPU를 사용자 프로그램으로 넘겨줄 때 모드비트를 1로 변경해줌
  - 커널 모드(0): 운영체제 코드 수행
    - 운영체제가 CPU를 제어할 때
    - 메모리 접근 뿐만 아니라 IO 장치 접근 또한 가능
    - 인터럽트로 인해 CPU가 운영체제로 제어권을 넘기면 모드비트를 0으로 바꾸게 됨
- 레지스터: 메모리보다 더 빠르고 작은 기억 장치
- 메모리: CPU의 작업 공간
  - CPU는 매 클럭마다 메모리에서 기계어를 한 줄씩 읽어서 실행

![Untitled](https://user-images.githubusercontent.com/67324487/230756002-617a49ce-c58a-44c2-99af-f8d38aaa6ebe.png)

- 디바이스 컨트롤러: 각각의 IO 장치를 통제하는 컨트롤러
  - control register, status register: CPU가 디바이스 컨트롤러에게 작업을 시킬 때 명령 전달용으로써 기능
  - 로컬 버퍼: 각 디바이스 컨트롤러의 작업 공간(일종의 메모리)
    - 실제 데이터는 로컬 버퍼에 담김
  - 디바이스 드라이버: 각 디바이스에 접근할 수 있게 하는 소프트웨어
  - 디바이스 컨트롤러: 각 디바이스 별로 그것을 전담하는 하드웨어

![Untitled](https://user-images.githubusercontent.com/67324487/230756001-243f7e88-2e51-451e-a015-313d33806a85.png)

- DMA 컨트롤러: 메모리에 직접 접근할 수 있는 컨트롤러
  - 키보드로 글자를 하나 입력하는 등의 작은 작업들이 버퍼에 일정량 이상 쌓이면 직접 버퍼에 있는 내용들을 한번에 메모리에 복사해오는 장치
    - CPU가 너무 자주 인터럽트 당하지 않게 CPU 대신 IO 작업의 결과를 메모리로 복사해주는 역할 수행 → 작업이 다 끝나면 DMA가 CPU에 직접 인터럽트(Block 단위의 인터럽트)를 걸어서 내용이 메모리에 모두 적재되었음을 확인시킴
  - 즉, CPU를 대신하여 IO 장치의 작업 내용을 메인 메모리로 복사하고 IO 작업이 마무리되면 CPU에게 인터럽트를 걸어 알리는 역할
- 메모리 컨트롤러: 메모리에 접근 가능한 CPU와 DMA 컨트롤러 사이에서 교통정리 역할 수행

![Untitled](https://user-images.githubusercontent.com/67324487/230756000-13fcba3b-6dbd-4586-99b8-36925208890c.png)

- 타이머
  - 특정 프로그램이 CPU를 독점하는 것을 방지하기 위해 정해진 시간이 흐른 뒤에 운영체제로 제어권이 넘어가도록 인터럽트를 발생시키는 역할 수행
  - 매 클럭 틱마다 1씩 감소하며 타이머 값이 0이 되면 타이머 인터럽트 발생
    - CPU는 실제로 기계어를 한 줄 실행한 뒤 인터럽트 라인을 확인하는 것을 반복
  - 운영체제는 CPU를 사용자 프로그램에 넘겨줄 때 타이머에 시간을 세팅함 → CPU는 사용자 프로그램을 실행 → 세팅된 시간이 되면 타이머가 CPU에게 인터럽트 → CPU의 제어권이 운영체제로 넘어감
- 하드디스크: 보조 기억 장치이자 IO 장치

### 인터럽트란

![Untitled](https://user-images.githubusercontent.com/67324487/230755998-a7d4ad36-dd54-474b-ac50-c6e31d257d3e.png)

- CPU가 특정 작업을 처리하는 도중에 다른 작업을 수행하도록 하기 위해 사용되는 기능
  - 인터럽트 발생 시 CPU는 진행 중이던 작업을 중단하고 인터럽트를 통해 요구되는 작업을 우선적으로 처리
- 인터럽트의 종류
  - Interrupt (하드웨어 인터럽트): 하드웨어가 발생시킨 인터럽트
    - IO 인터럽트: 입출력의 종료 또는 오류 등의 이유로 발생하는 인터럽트
  - Trap (소프트웨어 인터럽트)
    - Exception: 프로그램이 오류를 발생시킨 경우
      - 프로그램에서 명령어를 잘못 사용했거나 0으로 나누는 경우 등
    - System call: 프로그램이 커널 함수를 호출한 경우
      - 사용자 프로그램이 CPU를 점거하여 실행되고 있는 도중에 IO 작업이 필요한 경우
        - 사용자 프로그램은 운영체제를 통해서만 IO 장치에 접근 가능하므로 IO 작업이 필요하면 운영체제에게 시스템 콜을 통해 부탁함
        - IO 작업 필요 시 사용자 프로그램이 직접 인터럽트를 걺 → 모드비트가 0으로 바뀌고 CPU가 운영체제에게 넘어감 → IO 작업 수행 → IO 작업이 끝나면 하드웨어 인터럽트를 통해 종료를 알림
- 인터럽트 처리 루틴
  - 인터럽트의 종류가 여러 개이므로 각 인터럽트마다 수행하는 내용이 다 다름 → 인터럽트 별로 수행할 내용이 운영체제에 정의되어 있으며, 인터럽트 처리 루틴은 해당 처리 함수(코드)를 의미함
- 인터럽트 벡터
  - 인터럽트 별로 어느 주소의 함수를 실행해야 하는 지 해당 함수 주소를 정의해둔 것

### 운영체제의 역할

- CPU의 작동: 메모리에 적재된 사용자 프로그램은 CPU를 점거하여 실행되며, CPU는 매 클럭마다 프로그램의 기계어를 한 줄씩 실행 + 타이머 확인
- 인터럽트 발생
  - 프로그램이 직접 인터럽트를 발생시키는 경우
    - ex. 프로그램 실행 도중 키보드 입력을 받아야 하는 경우 → IO 작업이 필요하므로 인터럽트(시스템 콜) 발생
    - CPU가 운영체제로 넘어가며 운영체제가 해당 작업을 디바이스 컨트롤러에게 지시
      - CPU는 IO 장치에 직접 접근할 수 없으므로 디바이스 컨트롤러에게 입력을 받아오는 작업을 시킴
    - 디바이스 컨트롤러의 지시를 받아 IO 장치가 작업 수행하며, CPU는 다시 사용자 프로그램으로 돌아가 메모리 접근을 이어나감
    - 만약, 키보드의 입력이 꼭 필요한 작업이며 입력값이 없으면 프로그램 진행이 불가능한 경우 다른 프로그램으로 CPU 제어권이 넘어가게 됨
  - 디바이스 컨트롤러가 인터럽트를 발생시키는 경우
    - 사용자로부터 입력받은 데이터가 로컬 버퍼에 들어오면 디바이스 컨트롤러가 인터럽트 발생시킴 → CPU 제어권이 운영체제에게 돌아감
    - 운영체제는 입력받은 데이터를 로컬 버퍼에서 IO 작업을 요청한 사용자 프로그램의 메모리 공간으로 카피해둔 뒤, 실행 중이던 사용자 프로그램에게 다시 CPU 제어권을 양도
      - CPU는 메모리 뿐만 아니라 로컬 버퍼에도 접근 가능
    - 실행 중이던 사용자 프로그램의 할당 시간이 끝나면 CPU 제어권이 운영체제로 이동 → 운영체제가 IO 작업이 완료되어서 준비가 된 사용자 프로그램에게 CPU 제어권을 양도
    - DMA가 사용되는 경우
      - DMAC(DMAController)가 대신 입력받은 데이터를 메모리 공간에 카피한 뒤 인터럽트를 발생시켜 처리가 끝났음을 알림
  - 타이머가 인터럽트를 발생시키는 경우
    - 운영체제가 CPU를 점거하다가 사용자 프로그램에게 CPU 제어권을 넘겨줄 때 타이머에 시간을 세팅함
      - 무한 루프를 도는 프로그램을 만날 수도 있기 때문에

[출처](http://www.kocw.net/home/search/kemView.do?kemId=1046323&ar=pop)
